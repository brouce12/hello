#include "IWakeupService.h"
#include "AudioPreprocessDispatcher.h"
#include "log.h"
//#include "TwirlingWakeupApi.h"
#include "wakeupApi.h"
#include <iostream>
using namespace std;
#define MAXABS16S (32768)


const int IWakeupService::ANGLES_MIX_SIZE = 20;
IWakeupService::IWakeupService(float wakeupThreshold, float wakeupPlp, float wakeupDmin, float wakeupDmax)
	:wakeupThreshold(wakeupThreshold), wakeupPlp(wakeupPlp), wakeupDmin(wakeupDmin), wakeupDmax(wakeupDmax),
	 th_wakeup(0), isRun(false), audioData(NULL), m_wakeup_obj(NULL)
{
    pthread_cond_init(&this->dataArrivalCond, NULL);
    pthread_mutex_init(&this->dataArrivalMutex, NULL);
    /** init wakeup object */
    //m_wakeup_obj = WakeupInit(wakeupThreshold, wakeupPlp, wakeupDmin, wakeupDmax);
    int stride_len =  MicDataSource::FRAMELEN;
	 int chs = 1;
	 int sRate = 16000;
	 float detect_th = 0.7;
	//m_wakeup_obj = wakeupInit()

	m_wakeup_obj = wakeupInit(stride_len, chs, sRate, NULL, "", NULL, 1, detect_th, 1000, false);
	if(m_wakeup_obj != NULL){
		wakeupSet(m_wakeup_obj, detect_th);
	}
	printf("twirlingwakeupNN version: %s \n", "");
}
IWakeupService::~IWakeupService()
{
    isRun = false;
}

void IWakeupService::addWakeupListenner(WakeupListenner *listenner)
{
    this->wakeupListenners.push_back(listenner);
}
void IWakeupService::removeWakeupListenner(WakeupListenner *listenner)
{
    this->wakeupListenners.remove(listenner);
}
bool IWakeupService::getIsRun()
{
    return this->isRun;
}
void IWakeupService::stop()
{
    this->isRun = false;
}

void IWakeupService::run()
{
    if (!this->isRun)
    {
        pthread_create(&this->th_wakeup, NULL, m_wakeupProcess, (void *)this);
    }
}
short *IWakeupService::getAudioDataAddr()
{
    if (NULL == audioData)
    {
        audioData = (short *)malloc(MicDataSource::FRAMELEN * sizeof(short));
    }
    return audioData;
}
float IWakeupService::calcWakeupAngle()
{
    float sum = 0;
    int size = angles.size();
    int i = 0;
    list<float>::iterator it = angles.begin();
    // cout <<"------------Angle---------------" << endl;
    for (; it != angles.end(); ++it)
    {
        sum += *it;
        i++;
        if(i >= size)
        {
            break;
        }
        // cout << *it << " ";
    }
    // cout << endl <<"------------------------------" << endl;
    if(size == 0)
    {
        return 0;
    }
#ifdef DUMP_WAKEUP_DATA
    FILE *dumpWakeupDataOutput = NULL;
    if ((dumpWakeupDataOutput = fopen("/tmp/dump_wakeup_data.pcm", "wb")) == NULL)
    {
        macroFunc("wakeup: cannot open dump_wakeup_data file for wakeup");
        exit(1);
    }
    vector<short>::iterator iter = wakeupData.begin();
    for(; iter != wakeupData.end(); iter++)
    {
        fwrite(&(*iter), sizeof(short), 1, dumpWakeupDataOutput);
    }
    wakeupData.clear();
    fflush(dumpWakeupDataOutput);
    fclose(dumpWakeupDataOutput);
#endif
    return sum / angles.size();
}

#ifdef DUMP_WAKEUP_DATA
void IWakeupService::pushBackWakeupData(short *data, const int count)
{
    for(int i = 0; i < count; i++)
    {
        wakeupData.push_back(data[i]);
    }
}
void IWakeupService::popFrontWakeupData(const int count)
{
    if(wakeupData.size() >= count)
    {
        wakeupData.erase(wakeupData.begin(), wakeupData.begin()+count);
    }
}
#endif    
void IWakeupService::onDataArrival(short *audioData, float angle)
{
    memcpy(getAudioDataAddr(), audioData, MicDataSource::FRAMELEN * sizeof(short));
    if(angles.size() >= ANGLES_MIX_SIZE){
        angles.pop_front();
    }
    angles.push_back(angle);
#ifdef DUMP_WAKEUP_DATA
    if(wakeupData.size() >= MicDataSource::FRAMELEN * ANGLES_MIX_SIZE)
    {
        popFrontWakeupData(MicDataSource::FRAMELEN);
    }
    pushBackWakeupData(audioData, MicDataSource::FRAMELEN);
#endif
    pthread_cond_signal(&dataArrivalCond);
}
void *IWakeupService::m_wakeupProcess(void *p)
{
    pthread_detach(pthread_self());
    IWakeupService *wakeupService = (IWakeupService *)p;
    wakeupService->isRun = true;
    int isWakeup = 0;
    WakeupEvent *wakeupEvent = new WakeupEvent();
	int stride_len = MicDataSource::FRAMELEN;
	float* audio_buf_f = new float[stride_len];

    while (wakeupService->isRun)
    {
        pthread_mutex_lock(&wakeupService->dataArrivalMutex);
        pthread_cond_wait(&wakeupService->dataArrivalCond, &wakeupService->dataArrivalMutex);
        pthread_mutex_unlock(&wakeupService->dataArrivalMutex);
        /** wakeup process */

		
		static const float scale = 1.f / (float)(MAXABS16S);
		short * inputData16s = wakeupService->getAudioDataAddr();
		/** Convert input data from 16s to 32f. */
		for (int i = 0; i < stride_len; i++) {
			audio_buf_f[i] = (float)inputData16s[i] * scale;
		}
		
		
		int wakeupStatus = wakeupProcess(wakeupService->m_wakeup_obj, audio_buf_f);
		if (wakeupStatus == -1)
		{
			printf("Wakeup processing failed!\n");
		}
		else if (wakeupStatus == 1)
		{
			list<WakeupListenner *>::iterator it = wakeupService->wakeupListenners.begin();
            for (; it != wakeupService->wakeupListenners.end(); ++it)
            {
                wakeupEvent->setAngle(wakeupService->calcWakeupAngle());
                (*it)->onWakeup(wakeupEvent);
            }
			printf("\n=============Wakeup! \n");
		}
    }

    if (NULL != wakeupService->audioData)
    {
        free(wakeupService->audioData);
        wakeupService->audioData = NULL;
    }

    if (NULL != wakeupService->m_wakeup_obj)
    {
        wakeupRelease(wakeupService->m_wakeup_obj);
        wakeupService->m_wakeup_obj = NULL;
    }
    delete wakeupEvent;
	delete audio_buf_f;
    return NULL;
}
